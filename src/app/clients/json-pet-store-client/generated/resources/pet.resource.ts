/* @ts-nocheck */
/* eslint-disable */
/* @noformat */
/* @formatter:off */
/**
* Generated by ng-openapi
* `httpResource` is still an experimental feature - NOT PRODUCTION READY
* Generated Angular service for PetResource
* Do not edit this file manually
*/
import { HttpContext, HttpContextToken, HttpHeaders, HttpParams, httpResource, HttpResourceOptions, HttpResourceRef, HttpResourceRequest } from "@angular/common/http";
import { inject, Injectable, Signal } from "@angular/core";
import { BASE_PATH_PETSTOREJSON, CLIENT_CONTEXT_TOKEN_PETSTOREJSON } from "../tokens";
import { HttpParamsBuilder } from "../utils/http-params-builder";
import { Pet } from "../models";

@Injectable({ providedIn: "root" })
export class PetResource {
    private readonly basePath: string = inject(BASE_PATH_PETSTOREJSON);
    private readonly clientContextToken: HttpContextToken<string> = CLIENT_CONTEXT_TOKEN_PETSTOREJSON;

    private createContextWithClientId(existingContext?: HttpContext): HttpContext {
        const context = existingContext || new HttpContext();
        return context.set(this.clientContextToken, 'PetStoreJson');
    }

    findPetsByStatus(status: Signal<'available' | 'pending' | 'sold' | undefined> | 'available' | 'pending' | 'sold' | undefined, resourceOptions: HttpResourceOptions<Array<Pet>, unknown> & { defaultValue: NoInfer<Array<Pet>> }, requestOptions?: Omit<HttpResourceRequest, "method" | "url" | "params">): HttpResourceRef<Array<Pet>>;
    findPetsByStatus(status?: Signal<'available' | 'pending' | 'sold' | undefined> | 'available' | 'pending' | 'sold', resourceOptions?: HttpResourceOptions<Array<Pet>, unknown>, requestOptions?: Omit<HttpResourceRequest, "method" | "url" | "params">): HttpResourceRef<Array<Pet> | undefined>;
    /** Multiple status values can be provided with comma separated strings. */
    findPetsByStatus(status?: Signal<'available' | 'pending' | 'sold' | undefined> | 'available' | 'pending' | 'sold', resourceOptions?: HttpResourceOptions<Array<Pet>, unknown>, requestOptions?: Omit<HttpResourceRequest, "method" | "url" | "params">): HttpResourceRef<Array<Pet> | undefined> {
        return httpResource(() => {
            let params = new HttpParams();
            const statusValue = typeof status === 'function' ? status() : status;
            if (statusValue != null) {
                params = HttpParamsBuilder.addToHttpParams(params, statusValue, 'status');
            }
            return {
                url: `${this.basePath}/pet/findByStatus`,
                method: "GET",
                params,
                context: this.createContextWithClientId(requestOptions?.context),
                ...requestOptions
            }
        }, resourceOptions);
    }

    findPetsByTags(tags: Signal<Array<string> | undefined> | Array<string> | undefined, resourceOptions: HttpResourceOptions<Array<Pet>, unknown> & { defaultValue: NoInfer<Array<Pet>> }, requestOptions?: Omit<HttpResourceRequest, "method" | "url" | "params">): HttpResourceRef<Array<Pet>>;
    findPetsByTags(tags?: Signal<Array<string> | undefined> | Array<string>, resourceOptions?: HttpResourceOptions<Array<Pet>, unknown>, requestOptions?: Omit<HttpResourceRequest, "method" | "url" | "params">): HttpResourceRef<Array<Pet> | undefined>;
    /** Multiple tags can be provided with comma separated strings. Use tag1, tag2, tag3 for testing. */
    findPetsByTags(tags?: Signal<Array<string> | undefined> | Array<string>, resourceOptions?: HttpResourceOptions<Array<Pet>, unknown>, requestOptions?: Omit<HttpResourceRequest, "method" | "url" | "params">): HttpResourceRef<Array<Pet> | undefined> {
        return httpResource(() => {
            let params = new HttpParams();
            const tagsValue = typeof tags === 'function' ? tags() : tags;
            if (tagsValue != null) {
                params = HttpParamsBuilder.addToHttpParams(params, tagsValue, 'tags');
            }
            return {
                url: `${this.basePath}/pet/findByTags`,
                method: "GET",
                params,
                context: this.createContextWithClientId(requestOptions?.context),
                ...requestOptions
            }
        }, resourceOptions);
    }

    getPetById(petId: Signal<number> | number, resourceOptions: HttpResourceOptions<Pet, unknown> & { defaultValue: NoInfer<Pet> }, requestOptions?: Omit<HttpResourceRequest, "method" | "url" | "params">): HttpResourceRef<Pet>;
    getPetById(petId: Signal<number> | number, resourceOptions?: HttpResourceOptions<Pet, unknown>, requestOptions?: Omit<HttpResourceRequest, "method" | "url" | "params">): HttpResourceRef<Pet | undefined>;
    /** Returns a single pet. */
    getPetById(petId: Signal<number> | number, resourceOptions?: HttpResourceOptions<Pet, unknown>, requestOptions?: Omit<HttpResourceRequest, "method" | "url" | "params">): HttpResourceRef<Pet | undefined> {
        return httpResource(() => {
            return {
                url: `${this.basePath}/pet/${typeof petId === 'function' ? petId() : petId}`,
                method: "GET",
                context: this.createContextWithClientId(requestOptions?.context),
                ...requestOptions
            }
        }, resourceOptions);
    }
}
